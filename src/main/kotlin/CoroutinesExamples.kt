import kotlinx.coroutines.*
import kotlin.random.Random


// Суть корутин - отображать  события обладающие длительностью.
// Такие события обозначаются как suspend ("подвешенные") функции.
// Например, стандартная функция delay ждёт указанное количество миллисекунд.
// Или вот пример suspend функции readWord , которая ожидает и возвращает слово , которое пользователь введет в консоли.
suspend fun readWord()  = withContext(Dispatchers.IO){
     readLine()
}

fun main()  = runBlocking{
    // Suspend функции вызываются внутри CoroutineScope - области корутины.
    // runBlocking создает такую область.
    println("Введите тут Ваше имя:")
    println("Привет, ${readWord()}!")
    println()

    // Продолжительные события могут происходить параллельно.
    // С помощью launch мы можем запустить параллельную  корутину и взаимодейстовать с ней через  возвращаемый объект:
    // join - дождаться завершения ,  cancel - прервать выполнение корутины (прерывание произойдет в момент вызова suspend функции)
    println("В данном примере мы параллельно печатаем точки , в то время как Вы вводите здесь слово: ")
    val printDotsJob = launch {
        while (true){
            print(".")
            delay(300)
        }
    }

    val readWordJob = launch {
        readWord()
    }
    readWordJob.join()
    printDotsJob.cancel()
    println("")

    // Дочерние корутины , создаваемые через launch, связаны с текущей областью корутины -
    // родительская область  завершает работу,когда завершится работа во всех дочерних областях.
    // Таким образом , можно сказать, что родительская область включает в себя дочерние.

    println("Данный пример имитирует забег - 3 бегуна финишируют в случайное время в течение 5 секунд")

    suspend fun runner(name : String){
        delay(Random.nextLong(5000))
        println("$name прибежал")
    }

    coroutineScope {
        repeat(3){
            launch { runner("${it+1}") }
        }
    }
    println("Забег завершен")
}
